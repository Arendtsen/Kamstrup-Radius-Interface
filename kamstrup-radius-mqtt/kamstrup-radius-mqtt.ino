#include "gcm.h"
#include "mbusparser.h"

const size_t headersize = 11;
const size_t footersize = 3;
const uint8_t encryption_key[] =     {0x5A,0xD8,0x41,0x21,0xD9,0xD2,0x0B,0x36,0x4B,0x7A,0x11,0xF3,0xC1,0xB5,0x82,0x7F};
const uint8_t authentication_key[] = {0xAF,0xB3,0xF9,0x3E,0x3E,0x72,0x04,0xED,0xB3,0xC2,0x7F,0x96,0xDB,0xD5,0x1A,0xE0};
uint8_t input[] = {0x7E,0xA1,0xE9,0x41,0x03,0x13,0xC6,0x37,0xE6,0xE7,0x00,
0xDB,0x08,0x4B,0x41,0x4D,0x45,0x01,0xA4,0xDC,0x52,0x82,0x01,0xD0,0x30,0x00,0x07,0x88,0xE1,0xA0,0x39,0xB2,0xD1,0x4C,0x71,
0x2D,0xD4,0xD8,0xC8,0x44,0x0D,0x53,0x68,0xE4,0x33,0xBD,0x70,0xB7,0x36,0x81,0xE9,0xA9,0xEF,0xFE,0x38,0xF1,0x75,0xA3,0x7D,0xE9,0xCD,0xE6,0x4E,0x8F,
0x78,0x0D,0x8F,0x18,0xB4,0x3F,0xC0,0x59,0xD8,0x79,0x02,0xF3,0xD7,0x47,0xB8,0x14,0xBC,0xD0,0x6A,0x47,0x00,0x68,0x78,0x01,0xBD,0x5D,0x06,0x61,0x20,
0x54,0x50,0x7D,0x44,0xE7,0x66,0x98,0xCC,0x3E,0x35,0xCC,0x9D,0xE6,0x2C,0x28,0x4C,0x0D,0xEE,0xA6,0x35,0xB9,0xBF,0xC5,0x6C,0xE1,0xFE,0x5A,0x3A,0x1E,
0x5E,0x27,0x0B,0x0C,0x18,0x1A,0xCF,0x02,0x15,0x1F,0xCC,0x59,0x21,0x34,0xD0,0x4F,0x02,0x92,0xB5,0xA3,0x53,0x38,0xD7,0xB7,0x81,0xBB,0x1F,0x2A,0x7E,
0x40,0x71,0x81,0x5C,0xEE,0xD5,0xD4,0xBA,0xC6,0xEF,0xAA,0xAF,0xF9,0x79,0xEF,0x96,0x9D,0x0D,0xB4,0x6F,0x51,0xE5,0xE0,0xFC,0x00,0xF5,0xAD,0x10,0x5F,
0xBE,0xF9,0x5F,0xC5,0xF8,0x85,0x46,0x0B,0x56,0x32,0x55,0x4A,0xC0,0x5D,0x9E,0xB4,0xF6,0x5F,0xF2,0x23,0x97,0x2A,0x47,0xCF,0xD4,0x34,0xB5,0xF5,0xE2,
0xD8,0x53,0xEA,0x4C,0x14,0x72,0x75,0x86,0xF0,0xE2,0x1C,0x6E,0xE1,0x25,0x26,0x8C,0xB4,0xDC,0x7E,0xC5,0xB1,0x0F,0x84,0x83,0xC0,0x10,0xC8,0xE6,0x88,
0xDF,0x86,0x58,0x4D,0x7C,0x29,0xD8,0x17,0x31,0xA4,0xE0,0x96,0x91,0x41,0xB6,0xAD,0xD9,0x42,0xE4,0x0A,0x96,0xE3,0xE2,0xDC,0x2F,0x90,0x20,0xBF,0x9D,
0x58,0x02,0xA1,0x8D,0xC9,0x85,0xBB,0x54,0x22,0xF4,0x70,0xC0,0x62,0x9D,0x22,0xDB,0x6F,0x16,0xB6,0x64,0x7D,0xB3,0xC9,0xF7,0x27,0xC1,0x70,0xC2,0xDB,
0x4C,0x9A,0x23,0x0F,0x82,0x83,0x46,0xE8,0x6F,0x56,0xD3,0x47,0xB6,0x2B,0xFE,0x28,0xA5,0x07,0xAE,0x2A,0x21,0x9A,0xCC,0x63,0xAD,0x5E,0xE0,0x6E,0xCB,
0x94,0x9D,0xC4,0xFD,0xC2,0xD2,0xF8,0x08,0x02,0x7A,0x4A,0x4C,0x67,0x7C,0x93,0xC4,0xC8,0x90,0x9D,0x73,0x36,0xD8,0xB8,0xB3,0x79,0x18,0x36,0xC5,0x55,
0x5E,0x74,0xE2,0x54,0x82,0xA4,0x4A,0x5F,0x6D,0x35,0x8D,0xCE,0x84,0x50,0x47,0x8F,0x8B,0x2C,0x5D,0x56,0x66,0xC2,0xCF,0x8B,0xD1,0x90,0xD4,0x87,0x4E,
0x70,0x7F,0x5D,0x4B,0xCD,0xE9,0x4E,0x91,0x35,0x5A,0x81,0x39,0xC3,0xE4,0x1C,0xD5,0xF0,0x88,0x99,0xB6,0x5E,0xE9,0xB5,0x9F,0xC6,0x03,0x72,0xE4,0xF9,
0x2B,0xC9,0x98,0x26,0xB8,0xC1,0x47,0xF2,0x09,0x5F,0xB3,0x8A,0x89,0x14,0x09,0xAA,0x81,0xE2,0x27,0x07,0x6C,0x21,0xCB,0x7C,0xAF,0x73,0xB3,0xE8,0xA4,
0xE2,0x56,0xC7,0x0D,0x95,0x47,0xA9,0x14,0xF3,0x9C,0x16,0x93,0x76,0xBF,0x92,0x2B,0x08,0x06,0x4E,0xC4,0xFB,0x31,0xD4,0x4E,0xCD,0x72,0x1D,0x1A,0x15,
0x1E,0x4E,0x68,0x4F,0x0B,0x26,0x85,0xC4,0xB6,0x9D,0x96,0xF5,0xFB,0x52,0xD0,0xB8,0x12,0x79,
0x36,0x24,0x7E};

uint8_t receiveBuffer[1000];

mbedtls_gcm_context m_ctx;

void setup() {
  Serial.begin(115200);

  MbusStreamParser streamParser(receiveBuffer, sizeof(receiveBuffer));
  for(int i=0;i<sizeof(input);i++){
    if (streamParser.pushData(input[i])) {
      VectorView frame = streamParser.getFrame();
      if (streamParser.getContentType() == MbusStreamParser::COMPLETE_FRAME) {
        Serial.println("Frame complete");
        VectorView decryptFrame = decrypt(frame);
        MeterData md = parseMbusFrame(decryptFrame);
        if (md.activePowerPlusValid) {
          Serial.print("ActivePower: ");
          Serial.println(md.activePowerPlus);
        }
        if (md.voltageL1Valid) {
          Serial.print("Voltage L1: ");
          Serial.println(md.voltageL1);
        }
        if (md.voltageL2Valid) {
          Serial.print("Voltage L2: ");
          Serial.println(md.voltageL2);
        }
        if (md.voltageL3Valid) {
          Serial.print("Voltage L3: ");
          Serial.println(md.voltageL3);
        }
      } else {
        Serial.print(".");
      //writeDebugStringToBuf(debugbuf, sizeof(debugbuf), MeterData(), frame);
      }
    }
  }
}

void loop() {
  // put your main code here, to run repeatedly:

}

void printHex(const unsigned char* data,const size_t length) {
  for (int i = 0; i < length; i++) {
    Serial.printf("%02X", data[i]);
  }
}

void printHex(const VectorView& frame) {
  for (int i = 0; i < frame.size(); i++) {
    Serial.printf("%02X", frame[i]);
  }
}

const VectorView& decrypt(const VectorView& frame){

  if(frame.size() < headersize+footersize+12+18){
    Serial.println("Invalid frame size.");
  }
  uint8_t buf[frame.size()];
  memcpy(buf, &frame.front(), frame.size());
  
  Serial.print("Encryption Key:");
  printHex(encryption_key,sizeof(encryption_key));
  Serial.println();
  
  uint8_t system_title[8];
  memcpy(system_title, buf+headersize+2, 8);
  Serial.print("system_title:");
  printHex(system_title,sizeof(system_title));
  Serial.println();
  
  uint8_t initialization_vector[12];
  memcpy(initialization_vector,system_title,8);
  memcpy(initialization_vector+8,buf+headersize+14,4);
  Serial.print("initialization_vector:");
  printHex(initialization_vector,sizeof(initialization_vector));
  Serial.println();
  
  uint8_t additional_authenticated_data[17];
  memcpy(additional_authenticated_data,buf+headersize+13,1);
  memcpy(additional_authenticated_data+1,authentication_key,16);
  Serial.print("additional_authenticated_data:");
  printHex(additional_authenticated_data,sizeof(additional_authenticated_data));
  Serial.println();
  
  uint8_t authentication_tag[12];
  memcpy(authentication_tag,buf+headersize+frame.size()-headersize-footersize-12,12);
  Serial.print("authentication_tag:");
  printHex(authentication_tag,sizeof(authentication_tag));
  Serial.println();

  uint8_t cipher_text[frame.size()-headersize-footersize-18-12];
  memcpy(cipher_text,input+headersize+18,frame.size()-headersize-footersize-12-18);
  Serial.print("cipher_text:");
  printHex(cipher_text,sizeof(cipher_text));
  Serial.println();

  uint8_t plaintext[sizeof(cipher_text)];
   
  if(decryptWrapper(sizeof(cipher_text),cipher_text,plaintext,sizeof(authentication_tag),authentication_tag,sizeof(initialization_vector),initialization_vector,
      sizeof(additional_authenticated_data), additional_authenticated_data,sizeof(encryption_key)*8,encryption_key))
      {
        Serial.print("plaintext:");
        printHex(plaintext,sizeof(plaintext));
        Serial.println(); 
      }
  //copy replace encrypted data with decrypted for mbusparser library. Checksum not updated. Hopefully not needed
  memcpy(buf+headersize+18,plaintext,sizeof(plaintext));
  VectorView retFrame(buf,frame.size());
  Serial.print("Decrypted input:");
  printHex(retFrame);
  Serial.println(); 

  return retFrame;
}

bool decryptWrapper(const size_t length, const unsigned char* input, unsigned char* output,
                      const size_t tag_length, unsigned char* tag, const size_t iv_length,
                      unsigned char* iv, const size_t aad_length, const unsigned char* aad,
                      const size_t key_length_bits,const unsigned char* key) {
  mbedtls_gcm_init(&m_ctx);

  Serial.print("Keybits: ");
  Serial.println(key_length_bits);
  int success = mbedtls_gcm_setkey(&m_ctx, MBEDTLS_CIPHER_ID_AES, key, key_length_bits);
  if (0 != success ) {
    Serial.print("Setkey failed: ");
    Serial.println(success);
    return false;
  }

  success = mbedtls_gcm_auth_decrypt(&m_ctx, length, iv, iv_length, aad, aad_length, tag, tag_length, input, output);
  if (0 != success) {
    Serial.print("authdecrypt failed: ");
    Serial.println(success);
    return false;
  }
  mbedtls_gcm_free(&m_ctx);
}
